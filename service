(ns my-project.server
  (:require [clojure.core.async :refer [chan go timeout <!]] ; асинхронные каналы и таймеры
            [cheshire.core :as json] ; работа с JSON
            [ring.adapter.jetty :refer [run-jetty]] ; сервер на Jetty
            [ring.util.response :as resp] ; утилиты для ответов
            [ring.util.response :refer [response]] ; ответ в формате response
            [clojure.edn :as edn] ; обработка EDN форматов
            [clojure.java.io :as io] ; операции с файлами
            [clj-http.client :as client]) ; HTTP клиент для запросов
  (:import (ch.qos.logback.classic Level) ; логгирование
           (org.slf4j LoggerFactory))) ; логгирование

(def servers-file "servers.edn") ; файл для хранения информации о серверах
(def jobs (atom [])) ; атомарная структура для хранения задач
(def job-status (atom {})) ; атомарная структура для статуса задач
(def remote-functions (atom {})) ; атомарная структура для хранения удаленных функций

;; Функция для вызова удаленной функции по имени с аргументами.
(defn call-remote-function [name args]
  (if-let [f (get @remote-functions name)] ; если функция найдена в зарегистрированных
    (apply f args) ; вызываем функцию с аргументами
    (throw (Exception. (str "Function not found: " name))))) ; если не найдено - ошибка

;; Регистрация задачи и установка ее статуса как "registered"
(defn register-job [job-id job]
  (swap! jobs conj job) ; добавляем задачу в список
  (swap! job-status assoc job-id {:status "registered"}) ; обновляем статус задачи
  (println "Registered job:" job-id "Status: registered"))

;; Обновление статуса задачи
(defn update-job-status [job-id status]
  (swap! job-status assoc job-id {:status status}) ; меняем статус задачи
  (println "Updated job:" job-id "Status:" status))

;; Проверка и создание файла servers.edn, если он не существует
(defn ensure-servers-file []
  (when-not (.exists (io/file servers-file)) ; если файл не существует
    (spit servers-file "[]") ; создаем пустой файл
    (println "Created servers file at:" servers-file)))

;; Обновление нагрузки на сервер
(defn update-server-load [server-id delta]
  (ensure-servers-file) ; убедимся, что файл существует
  (let [servers (edn/read-string (slurp servers-file)) ; читаем список серверов из файла
        updated-servers (mapv (fn [s] ; обновляем нагрузку на нужный сервер
                                (if (= (:id s) server-id) ; если сервер найден
                                  (update s :load + delta) ; увеличиваем или уменьшаем нагрузку
                                  s)) servers)]
    (spit servers-file (pr-str updated-servers)) ; записываем обновленные данные обратно в файл
    (println "Updated server load for" server-id "by" delta))) ; выводим информацию об изменении

;; Регистрация удаленной функции
(defn register-remote-function [name f]
  (swap! remote-functions assoc name f) ; добавляем функцию в список зарегистрированных
  (println "Registered remote function:" name)
  (println "Current remote functions:" @remote-functions)) ;; Выводим для отладки

;; Обработчик регистрации удаленной функции через HTTP-запрос
(defn register-function-handler [req server-id]
  (let [body (slurp (:body req)) ; читаем тело запроса
        func-data (json/parse-string body true) ; парсим JSON в данные функции
        func-name (:name func-data) ; извлекаем имя функции
        func-code (:code func-data) ; извлекаем код функции
        job-id (java.util.UUID/randomUUID)] ; генерируем уникальный ID задачи

    ;; Отладочная информация
    (println "Function data:" func-data)
    (println "Function name:" func-name)
    (println "Function code:" func-code)

    (try
      (let [func (eval (read-string func-code))] ; компилируем и выполняем код функции
        (register-remote-function (symbol func-name) func) ; регистрируем функцию
        (update-job-status job-id "registered") ; обновляем статус задачи
        (response (json/generate-string {:status "Function registered" :name func-name}))) ; отправляем ответ
      (catch Exception e
        (println "Failed to register function:" (.getMessage e)) ; в случае ошибки
        (update-job-status job-id "failed")
        (response (json/generate-string {:error (.getMessage e)}))))) ; отправляем ошибку

;; Обработчик проверки наличия удаленной функции
(defn check-function-handler [req]
  (println "Received request:" req) ; Отладочная информация
  (let [func-name (get-in req [:query-params "func"])] ; извлекаем имя функции из параметров запроса
    (println "Checking function name:" func-name) ; Отладочная информация
    (if (nil? func-name)
      (response (json/generate-string {:available false :error "Function name cannot be nil"}))
      (let [func-symbol (symbol func-name)] ; проверяем, зарегистрирована ли функция
        (if (contains? @remote-functions func-symbol)
          (response (json/generate-string {:available true}))
          (response (json/generate-string {:available false :error "Function not found"}))))))

;; Основной обработчик задач
(defn job-handler [req server-id]
  (let [uri (:uri req)] ; извлекаем URI запроса
    (if (= uri "/register-function")
      (register-function-handler req server-id) ; обработка регистрации функции
      (let [body (slurp (:body req)) ; читаем тело запроса
            job (json/parse-string body true) ; парсим запрос в структуру данных
            remote-func (:remote-func job) ; извлекаем удаленную функцию
            java-object (:java-object job) ; извлекаем Java объект
            args (:args job) ; аргументы функции
            clojure-code (:clojure-code job) ; Clojure код
            job-id (java.util.UUID/randomUUID)] ; генерируем ID задачи

        (register-job job-id job) ; регистрируем задачу
        (update-server-load server-id 1) ; увеличиваем нагрузку на сервер

        (try
          (let [result (cond
                         remote-func (call-remote-function (symbol remote-func) args) ; вызов удаленной функции
                         clojure-code (eval (read-string clojure-code)) ; выполнение Clojure кода
                         java-object (let [parsed-java-object (json/parse-string java-object true)]
                                       (str "Java object - Name: " (:name parsed-java-object) ", Age: " (:age parsed-java-object))) ; обработка Java объекта
                         :else (throw (Exception. "Invalid job type")))] ; ошибка, если не указан тип задачи
            (update-server-load server-id -1) ; уменьшаем нагрузку на сервер
            (response (json/generate-string {:result result}))) ; отправляем результат
          (catch Exception e
            (update-server-load server-id -1) ; уменьшаем нагрузку при ошибке
            (println "Job failed:" job-id "Error:" (.getMessage e)) ; выводим ошибку
            (update-job-status job-id "failed")
            (response (json/generate-string {:error (.getMessage e)})))))))

;; Настройка логирования для Jetty
(defn configure-logging []
  (let [logger (LoggerFactory/getLogger "org.eclipse.jetty")]
    (.setLevel logger Level/WARN))) ; устанавливаем уровень логирования

;; Запуск сервера
(defn start-server []
  (let [server-id (str (java.util.UUID/randomUUID)) ; генерируем уникальный ID сервера
        keep-alive-ch (chan) ; канал для keep-alive сообщений
        server (run-jetty
                (fn [req] ; основная обработка запросов
                  (cond
                    (= (:uri req) "/check-function") (check-function-handler req) ; проверка функции
                    (= (:uri req) "/keep-alive") (do ; обработка keep-alive сигнала
                                                   (println "Received keep-alive signal")
                                                   (update-server-load server-id -1)
                                                   (response (json/generate-string {:status "OK"})))
                    :else (job-handler req server-id))) ; обработка задач
                {:port 0 :join? false}) ; запуск на случайном порту
        port (-> server .getConnectors first .getLocalPort)] ; получение порта сервера

    (ensure-servers-file) ; проверка файла серверов
    (let [servers (edn/read-string (slurp servers-file)) ; чтение списка серверов
          server-info {:id server-id :port port :load 0}] ; информация о сервере
      (spit servers-file (pr-str (conj servers server-info))) ; добавление сервера в список
      (println "Server registered with ID:" server-id "on port:" port))

    ;; Запуск фоновой задачи для отправки keep-alive сигналов
    (go
      (loop []
        (<! (timeout (* 30 60 1000))) ;; Ожидание 30 минут
        (client/get (str "http://localhost:" port "/keep-alive")) ;; Отправка сигнала
        (recur)))

    server)) ; возвращаем объект сервера

;; Пример удаленной функции (сложение)
(defn add [a b]
  (+ a b))

;; Регистрация удаленных функций
(defn register-remote-functions []
  (register-remote-function 'add add)) ; регистрируем функцию сложения

;; Основная функция для старта сервера
(defn -main [& args]
  (configure-logging) ; настройка логирования
  (register-remote-functions) ; регистрация удаленных функций
  (start-server)) ; запуск сервера

(-main) ; запуск приложения
