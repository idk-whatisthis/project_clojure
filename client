(ns my-project.client
  ;; Подключение необходимых библиотек
  (:require [cheshire.core :as json] ;; Работа с JSON
            [clojure.edn :as edn] ;; Работа с EDN
            [clojure.java.io :as io] ;; Работа с файловой системой
            [clj-http.client :as client] ;; HTTP-клиент для запросов
            [clojure.core.async :as async :refer [<! >! go chan close!]])) ;; Асинхронные каналы

;; Импорт класса для работы с сокетами
(import '[java.net Socket])

;; Путь к файлу с данными о серверах
(def servers-file "servers.edn")

;; Чтение списка доступных серверов из файла
(defn get-available-servers []
  (try
    (when (.exists (io/file servers-file)) ;; Проверяем существование файла
      (let [servers (edn/read-string (slurp servers-file))] ;; Читаем данные
        (println "Available servers:" servers)
        servers)) ;; Возвращаем список серверов
    (catch Exception e
      (println "Failed to read servers list:" (.getMessage e))
      []))) ;; В случае ошибки возвращаем пустой список

;; Проверяет, активен ли сервер
(defn is-server-active? [server]
  (try
    (with-open [socket (Socket. "localhost" (:port server))] ;; Пробуем подключиться к серверу
      true) ;; Если получилось, сервер активен
    (catch Exception e
      false))) ;; В случае ошибки сервер не активен

;; Проверяет, развернута ли функция на сервере
(defn is-code-deployed? [server func]
  (if (nil? func)
    false ;; Если функция не задана, возвращаем false
    (try
      (let [url (str "http://localhost:" (:port server) "/check-function") ;; URL для проверки функции
            response (client/get url {:query-params {:func (name func)}})] ;; Отправляем запрос
        (= 200 (:status response))) ;; Проверяем статус ответа
      (catch Exception e
        (println "Error checking function deployment:" (.getMessage e))
        false)))) ;; Если ошибка, считаем, что функция не развернута

;; Выбирает сервер для выполнения задания
(defn choose-server [func]
  (let [servers (get-available-servers)] ;; Получаем список серверов
    (if (empty? servers)
      (do
        (println "No available servers.")
        nil) ;; Если серверов нет, возвращаем nil
      (let [active-servers (filter #(is-server-active? %) servers)] ;; Фильтруем активные серверы
        (if (empty? active-servers)
          (do
            (println "No suitable servers available.")
            nil) ;; Если активных серверов нет, возвращаем nil
          (let [selected-server (apply min-key :load active-servers)] ;; Выбираем сервер с минимальной нагрузкой
            (println "Selected server:" selected-server)
            selected-server))))))

;; Сериализует Java-объект в строку JSON
(defn serialize-java-object-to-string [obj]
  (json/generate-string obj)) ;; Используем cheshire для сериализации

;; Отправляет задание на сервер
(defn submit-job [func args clojure-code java-object]
  (let [server (choose-server func)] ;; Выбираем сервер для выполнения задания
    (if server
      (let [url (str "http://localhost:" (:port server)) ;; Формируем URL
            request-body (json/generate-string ;; Формируем тело запроса
                          (cond-> {}
                            func (assoc :remote-func (name func) :args args)
                            clojure-code (assoc :clojure-code clojure-code)
                            java-object (assoc :java-object (serialize-java-object-to-string java-object))))
            response-chan (chan)] ;; Создаем канал для получения результата
        (go
          (let [response (<! (async/thread
                               (client/post url ;; Отправляем запрос на выполнение задания
                                            {:body request-body
                                             :headers {"Content-Type" "application/json"}})))]
            (if (= 200 (:status response)) ;; Проверяем статус ответа
              (let [result (json/parse-string (:body response) true)] ;; Парсим результат
                (when result
                  (println "Result:" result))
                (>! response-chan result) ;; Отправляем результат в канал
                (close! response-chan))  ;; Закрываем канал
              (do
                (println "Failed to submit job:" (:status response) (:body response))
                (>! response-chan nil) ;; В канал отправляем nil при ошибке
                (close! response-chan)))))
        response-chan) ;; Возвращаем канал с результатом
      (do
        (println "No server selected. Job not submitted.")
        nil)))) ;; Если сервер не выбран, возвращаем nil

;; Регистрирует удалённую функцию на сервере
(defn register-remote-function [name code]
  (let [server (choose-server nil)] ;; Выбираем сервер
    (if server
      (try
        (let [url (str "http://localhost:" (:port server) "/register-function") ;; URL регистрации функции
              request-body (json/generate-string {:name name :code code})] ;; Формируем запрос
          (println "Registering function..." name)
          (let [response (client/post url {:body request-body :headers {"Content-Type" "application/json"}})] ;; Отправляем запрос
            (if (= 200 (:status response)) ;; Проверяем статус ответа
              (println "Function registered:" name)
              (println "Failed to register function:" (:status response) (:body response)))))
        (catch Exception e
          (println "Connection error:" (.getMessage e)))) ;; Ловим ошибки соединения
      (println "No server selected. Function not registered.")))) ;; Если сервер не выбран, регистрация невозможна

;; Параллельное выполнение функции `map`
(defn parallel-map [func args]
  (let [results (atom (vec (repeat (count args) nil))) ;; Создаем атом для хранения результатов
        jobs (chan)] ;; Канал для отслеживания завершения задач
    (doseq [idx (range (count args))] ;; Перебираем индексы всех аргументов
      (let [arg (nth args idx)] ;; Получаем аргумент по индексу
        (go
          (let [result (<! (submit-job func [arg arg] nil nil))] ;; Отправляем задание на сервер
            (when result
              (swap! results assoc idx (:result result)) ;; Обновляем результаты в атоме
              (>! jobs :done)))))) ;; Отправляем сигнал завершения в канал
    ;; Ждем завершения всех задач
    (go
      (dotimes [_ (count args)]
        (<! jobs)) ;; Читаем из канала сигналы завершения
      @results))) ;; Возвращаем результаты

;; Пример отправки и выполнения Clojure-кода
(defn submit-clojure-code-example []
  (let [code "(+ 10 2)"] ;; Пример кода на Clojure
    (println "Submitting Clojure code...")
    (let [result (submit-job nil nil code nil)] ;; Отправляем задание с кодом
      (when result
        (println "Result of executing Clojure code:" result))))) ;; Печатаем результат выполнения

;; Пример отправки Java-объекта
(defn submit-java-object-example []
  (let [person {:name "Alice" :age 30}] ;; Пример объекта
    (println "Submitting Java object...")
    (let [result (submit-job nil nil nil person)] ;; Отправляем задание с Java-объектом
      (when result
        (println "Result of sending Java object:" result))))) ;; Печатаем результат выполнения

;; Пример отправки удалённой функции для выполнения
(defn submit-remote-function-example []
  (let [func 'add  ;; Имя удалённой функции
        args [6 7]] ;; Аргументы для функции
    (println "Submitting remote function...")
    (let [result (submit-job func args nil nil)] ;; Отправляем задание с функцией
      (when result
        (println "Result of remote function:" (:result result)))))) ;; Печатаем результат выполнения

;; Пример использования parallel-map
(defn submit-parallel-map-example []
  (let [func 'add ;; Указываем имя функции
        args [1 2 3 4 5]] ;; Список аргументов
    (println "Submitting parallel map...")
    (let [results (parallel-map func args)] ;; Вызываем параллельное выполнение
      (println "Results of parallel map:" results)))) ;; Печатаем результаты выполнения

;; Пример отправки другой удалённой функции
(defn submit-remote-function-example_new []
  (let [func 'subtract  ;; Имя другой функции
        args [17 7]] ;; Аргументы
    (println "Submitting remote function...")
    (let [result (submit-job func args nil nil)] ;; Отправляем задание
      (when result
        (println "Result of remote function:" (:result result)))))) ;; Печатаем результат выполнения

;; Последовательное выполнение примеров
(submit-clojure-code-example) ;; Пример выполнения Clojure-кода
(submit-java-object-example) ;; Пример отправки Java-объекта
(submit-remote-function-example) ;; Пример вызова удаленной функции
(submit-parallel-map-example) ;; Пример параллельного выполнения
(submit-remote-function-example_new) ;; Пример вызова другой функции

